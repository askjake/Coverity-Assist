# app/app.py
from fastapi import FastAPI, HTTPException, Body
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
import os, json, requests

from .middleware import RequestTelemetryMiddleware, set_token_usage

# ---------- Helpers ----------
def _first_nonempty_env(*names: str) -> str:
    for n in names:
        v = os.getenv(n) or ""
        if v.strip():
            return v.strip()
    return ""

def get_inference_profile_arn() -> str:
    # accept any of these; first non-empty wins
    return _first_nonempty_env(
        "INFERENCE_PROFILE_ARN",
        "APPLICATION_INFERENCE_PROFILE_ARN",
        "BEDROCK_APPLICATION_INFERENCE_PROFILE_ARN",
        "BEDROCK_INFERENCE_PROFILE_ARN",
        "APPLICATION_PROFILE_ARN",
        "PROFILE_ARN",
    )

def get_token_len() -> int:
    return len(os.getenv("COVERITY_ASSIST_TOKEN", ""))

def bearer_headers() -> Dict[str, str]:
    return {
        "Authorization": f"Bearer {os.getenv('COVERITY_ASSIST_TOKEN','')}",
        "Content-Type": "application/json",
    }

COVERITY_ASSIST_URL = (os.getenv("COVERITY_ASSIST_URL",
                      "http://coverity-assist.dishtv.technology/chat").rstrip("/"))

# ---------- FastAPI app ----------
app = FastAPI(title="coverity-assist-proxy", version="1.0")

# single, real middleware attachment
app.add_middleware(
    RequestTelemetryMiddleware,
    infer_arn_getter=get_inference_profile_arn,
    token_len_getter=get_token_len,
)

# ---------- Models ----------
class ChatIn(BaseModel):
    messages: List[Dict[str, Any]]
    max_tokens: int = 800
    system: Optional[str] = None
    inference_profile_arn: Optional[str] = None

class ValidateIn(BaseModel):
    original_request: str
    summary: str
    max_tokens: int = 300

# ---------- Routes ----------
@app.get("/health")
def health():
    arn = get_inference_profile_arn()
    return {
        "status": "OK",
        "has_token": get_token_len() > 0,
        "inference_profile_arn": arn or None,
    }

@app.post("/chat")
def chat(body: ChatIn = Body(...)):
    if get_token_len() == 0:
        raise HTTPException(status_code=401, detail="Missing COVERITY_ASSIST_TOKEN")

    payload: Dict[str, Any] = {
        "messages": body.messages,
        "max_tokens": body.max_tokens,
    }
    if body.system:
        payload["system"] = body.system

    ipa = body.inference_profile_arn or get_inference_profile_arn()
    if ipa:
        payload["inference_profile_arn"] = ipa

    r = requests.post(COVERITY_ASSIST_URL, headers=bearer_headers(), json=payload, timeout=120)
    try:
        r.raise_for_status()
    except requests.HTTPError as e:
        raise HTTPException(status_code=r.status_code, detail=r.text) from e

    # If upstream includes token usage in JSON, you can call:
    # set_token_usage(r.json().get("usage", {}).get("total_tokens"))
    return r.json()

@app.post("/validate")
def validate(body: ValidateIn):
    if get_token_len() == 0:
        raise HTTPException(status_code=401, detail="Missing COVERITY_ASSIST_TOKEN")

    system = "Return STRICT JSON only. No prose."
    user = (
        "Original request:\n---\n" + body.original_request + "\n---\n\n"
        "Did the summary below fully satisfy the request? If not, list concrete next actions "
        "(bash commands or URLs) we should run/fetch next.\n\n"
        "Summary:\n---\n" + body.summary + "\n---\n\n"
        'Respond JSON with keys: "complete": true|false, "next_actions": [ {"cmd": "."}, {"url": "."} ]'
    )

    payload: Dict[str, Any] = {
        "messages": [{"role": "user", "content": user}],
        "max_tokens": body.max_tokens,
        "system": system,
    }

    ipa = get_inference_profile_arn()
    if ipa:
        payload["inference_profile_arn"] = ipa

    r = requests.post(COVERITY_ASSIST_URL, headers=bearer_headers(), json=payload, timeout=120)
    try:
        r.raise_for_status()
    except requests.HTTPError as e:
        raise HTTPException(status_code=r.status_code, detail=r.text) from e

    try:
        upstream = r.json()
    except ValueError:
        upstream = {}

    textish = upstream.get("content") or upstream.get("response") or upstream.get("text") or r.text
    try:
        data = json.loads(textish)
        if not isinstance(data, dict):
            data = {}
    except Exception:
        data = {}

    data.setdefault("complete", False)
    data.setdefault("next_actions", [])
    return data

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("app:app", host="0.0.0.0", port=int(os.getenv("PORT","8000")))

